# О-нотация
# Константным, или постоянным по времени, называется алгоритм, который выполняет необходимое действие всегда за
# одинаковое количество времени:

# присваивание;
# арифметические операции;
# логические операции;
# сравнение объектов;
# некоторые другие действия

# Для оценки сложности алгоритмов существуют три математические величины:
# «О» большая — верхняя оценка сложности алгоритма;
# «Ω» (омега) — нижняя оценка сложности;
# «Θ» (тета) — точная оценка сложности.


# Сложность алгоритма	                  О-нотация	                                                Примеры
# Константная	                          O(1)	                                           Сложение, присваивание
# Логарифмическая	                      O(log(n))	                                      Разрезание бумаги на части
# Линейная	                              O(n)	                                 Поиск максимального элемента из списка
# Квадратичная	                          O(n^2)	                             Расстановка книг в алфавитном порядке
# Полиномиальная	                      O(n^k)	                             О таких алгоритмах лучше не знать
# Факториальная	                          O(n!)                               А это ужас для всех программистов

# Основные структуры данных

# Структура данных — это программная единица, позволяющая хранить и обрабатывать множество логически связанных объектов.

# Массив — это упорядоченный набор данных.

# Статические массивы - для них заранее резервируется фиксированная область памяти.
# Динамические массивы с помощью буферного механизма могут изменять свой размер.

#  logical size — фактическая заполненность массива;
#  capacity — вместимость памяти для этого массива.

# Хэш-таблицы
# Каждое значение обладает ключом доступа к нему. Все значения хранятся в  массиве, а в качестве индекса используется
# результат хэширования ключа.

# Хэширование - это преобразование объекта, выступающего ключом, в целое число — индекс,
# используемый для доступа к значению.

# Основные структуры данных: список, стек, очередь

# Списки: односвязные и двусвязные

# Список — это упорядоченный набор элементов. Но, в отличие от массива, который хранится последовательно в одной области
# памяти, и каждой ячейке линейно соответствует определённый индекс, список может быть хаотично распределён в памяти.
# Порядок в этой структуре данных задаётся наличием указателей на следующий (и/или предыдущий) элемент в списке.

# Стек (stack)
# структура данных, реализующая LIFO
# Last In First Out (последний вошёл — первый вышел)

def paren_checker(string):
    stack = []  # объявляем стек

    for s in string:
        if s == "(":
            stack.append(s)  # добавляем скобку в стек
        elif s == ")":
            # если находим закрывающую скобку, то проверяем,
            # пуст ли стек, и является ли верхний элемент открывающей скобкой
            if len(stack) > 0 and stack[-1] == "(":
                stack.pop()  # удаляем из стека
            else:  # иначе завершаем функцию с False
                return False
    return len(stack) == 0


# Нелинейные структуры данных: графы и деревья

# Граф — это структура, имеющая узлы (вершины графа) и связи между ними (ребра).
G = {"Адмиралтейская":
         ["Садовая"],
     "Садовая":
         ["Сенная площадь",
          "Спасская",
          "Адмиралтейская",
          "Звенигородская"],
     "Сенная площадь":
         ["Садовая",
          "Спасская"],
     "Спасская":
         ["Садовая",
          "Сенная площадь",
          "Достоевская"],
     "Звенигородская":
         ["Пушкинская",
          "Садовая"],
     "Пушкинская":
         ["Звенигородская",
          "Владимирская"],
     "Владимирская":
         ["Достоевская",
          "Пушкинская"],
     "Достоевская":
         ["Владимирская",
          "Спасская"]}


# Линейный поиск
# Линейный алгоритм поиска может применяться для следующих целей:
#
# Нахождение минимального / максимального элемента.
# Поиск элемента с определённым значением.
# Количество вхождений элемента в массив.
# Количество элементов больше заданного.


def find(array, element):
    for i, a in enumerate(array):
        if a == element:
            return i
    return False


array = list(map(int, input("Введите последовательность чисел через пробел: ").split()))
element = int(input("Введите любое число: "))

print(find(array, element))


# Двоичный поиск

def binary_search(array, element, left, right):
    middle = (right + left) // 2  # находим середину
    if array[middle] == element:  # если элемент в середине,
        return middle  # возвращаем этот индекс
    elif element < array[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(array, element, left, middle - 1)
    else:  # иначе в правой
        return binary_search(array, element, middle + 1, right)


element = int(input("Введите любое число от 1 до 100: "))
array = [i for i in range(1, 101)]

# запускаем алгоритм на левой и правой границе
print(binary_search(array, element, 0, 100))

# Алгоритмы сортировки
# Сортировка выбором
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]

for i in range(len(array)):  # проходим по всему массиву
    ind_min = i  # сохраняем индекс предположительно минимального элемента
    for j in range(i, len(array)):
        if array[j] < array[ind_min]:
            ind_min = j
    if i != ind_min:  # если индекс не совпадает с минимальным, меняем
        array[i], array[ind_min] = array[ind_min], array[i]

print(array)

# Сортировка пузырьком

array = [2, 3, 1, 4, 6, 5, 9, 8, 7]

for i in range(len(array)):
    for j in range(len(array) - i - 1):
        if array[j] > array[j + 1]:
            array[j], array[j + 1] = array[j + 1], array[j]

print(array)

# Сортировка вставками
array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
for i in range(1, len(array)):
    x = array[i]
    idx = i
    while idx > 0 and array[idx-1] > x:
        array[idx] = array[idx-1]
        idx -= 1
    array[idx] = x
print(array)

